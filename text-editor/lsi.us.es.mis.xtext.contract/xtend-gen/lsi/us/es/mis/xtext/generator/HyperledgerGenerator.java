/**
 * generated by Xtext 2.25.0
 */
package lsi.us.es.mis.xtext.generator;

import com.google.common.base.Objects;
import java.util.HashMap;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import lsi.us.es.mis.xtext.contract.Attribute;
import lsi.us.es.mis.xtext.contract.Contract;
import lsi.us.es.mis.xtext.contract.DataStore;
import lsi.us.es.mis.xtext.contract.Event;
import lsi.us.es.mis.xtext.contract.Method;
import lsi.us.es.mis.xtext.contract.Param;
import lsi.us.es.mis.xtext.contract.Validator;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.xtext.generator.AbstractGenerator;
import org.eclipse.xtext.generator.IFileSystemAccess2;
import org.eclipse.xtext.generator.IGeneratorContext;
import org.eclipse.xtext.xbase.lib.Conversions;
import org.eclipse.xtext.xbase.lib.IterableExtensions;

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
@SuppressWarnings("all")
public class HyperledgerGenerator extends AbstractGenerator {
  @Override
  public void doGenerate(final Resource resource, final IFileSystemAccess2 fsa, final IGeneratorContext context) {
    EObject _head = IterableExtensions.<EObject>head(resource.getContents());
    Contract contract = ((Contract) _head);
    String _name = contract.getName();
    String _plus = (_name + ".go");
    fsa.generateFile(_plus, this.toHyperledger(contract));
  }
  
  public String toHyperledger(final Contract contract) {
    final StringBuilder code = new StringBuilder();
    this.appendHeader(contract, code);
    this.appendAttributes(contract, code);
    this.appendMethods(contract, code);
    this.appendConstructor(contract, code);
    this.appendMain(contract, code);
    return code.toString();
  }
  
  public StringBuilder appendHeader(final Contract contract, final StringBuilder code) {
    StringBuilder _xblockexpression = null;
    {
      code.append("package main\n\n");
      code.append("import (\n");
      code.append("\t\"fmt\"\n");
      code.append("\n");
      code.append("\t\"github.com/hyperledger/fabric-contract-api-go/contractapi\"\n");
      _xblockexpression = code.append(")\n\n");
    }
    return _xblockexpression;
  }
  
  public StringBuilder appendConstructor(final Contract contract, final StringBuilder code) {
    StringBuilder _xblockexpression = null;
    {
      String _name = contract.getName();
      String _plus = ("func (sc *" + _name);
      String _plus_1 = (_plus + ") InitLedger(ctx contractapi.TransactionContextInterface) error {\n");
      code.append(_plus_1);
      EList<Attribute> _attributes = contract.getAttributes();
      for (final Attribute attribute : _attributes) {
        {
          final String attributeName = attribute.getName();
          final String defaultValue = this.getDefaultInitialValue(attribute.getType().toString());
          String _capitalizeFirstLetter = this.capitalizeFirstLetter(attributeName);
          String _plus_2 = ("\tsc." + _capitalizeFirstLetter);
          String _plus_3 = (_plus_2 + " = ");
          String _plus_4 = (_plus_3 + defaultValue);
          String _plus_5 = (_plus_4 + "\n");
          code.append(_plus_5);
        }
      }
      boolean _isOwnership = contract.isOwnership();
      if (_isOwnership) {
        code.append("\tsc.Owner = ctx.GetClientIdentity().GetID()\n");
      }
      code.append("\treturn nil\n");
      _xblockexpression = code.append("}\n\n");
    }
    return _xblockexpression;
  }
  
  public StringBuilder appendAttributes(final Contract contract, final StringBuilder code) {
    StringBuilder _xblockexpression = null;
    {
      String _name = contract.getName();
      String _plus = ("type " + _name);
      String _plus_1 = (_plus + " struct {\n");
      code.append(_plus_1);
      code.append("\tcontractapi.Contract\n");
      boolean _isOwnership = contract.isOwnership();
      if (_isOwnership) {
        code.append("\tOwner string\n");
      }
      EList<DataStore> _dataStores = contract.getDataStores();
      for (final DataStore map : _dataStores) {
        String _name_1 = map.getName();
        String _plus_2 = ("\t" + _name_1);
        String _plus_3 = (_plus_2 + " map[");
        String _correctType = this.getCorrectType(map.getFromType().toString());
        String _plus_4 = (_plus_3 + _correctType);
        String _plus_5 = (_plus_4 + "]");
        String _correctType_1 = this.getCorrectType(map.getToType().toString());
        String _plus_6 = (_plus_5 + _correctType_1);
        String _plus_7 = (_plus_6 + "\n");
        code.append(_plus_7);
      }
      EList<Attribute> _attributes = contract.getAttributes();
      for (final Attribute attribute : _attributes) {
        {
          final String attributeName = attribute.getName();
          final String attributeType = this.getCorrectType(attribute.getType().toString());
          String _capitalizeFirstLetter = this.capitalizeFirstLetter(attributeName);
          String _plus_8 = ("\t" + _capitalizeFirstLetter);
          String _plus_9 = (_plus_8 + " ");
          String _plus_10 = (_plus_9 + attributeType);
          String _plus_11 = (_plus_10 + "\n");
          code.append(_plus_11);
        }
      }
      _xblockexpression = code.append("}\n\n");
    }
    return _xblockexpression;
  }
  
  public StringBuilder appendMethods(final Contract contract, final StringBuilder code) {
    StringBuilder _xblockexpression = null;
    {
      EList<Attribute> _attributes = contract.getAttributes();
      for (final Attribute attribute : _attributes) {
        {
          final String attributeName = attribute.getName();
          final String capitalizeAttributeName = this.capitalizeFirstLetter(attributeName);
          final String attributeType = this.getCorrectType(attribute.getType().toString());
          boolean _isModifiable = attribute.isModifiable();
          if (_isModifiable) {
            String _name = contract.getName();
            String _plus = ("func (sc *" + _name);
            String _plus_1 = (_plus + ") Set");
            String _plus_2 = (_plus_1 + capitalizeAttributeName);
            String _plus_3 = (_plus_2 + "(ctx contractapi.TransactionContextInterface, value ");
            String _plus_4 = (_plus_3 + attributeType);
            String _plus_5 = (_plus_4 + ") error {\n");
            code.append(_plus_5);
            String _capitalizeFirstLetter = this.capitalizeFirstLetter(attributeName);
            String _plus_6 = ("\tsc." + _capitalizeFirstLetter);
            String _plus_7 = (_plus_6 + " = value\n");
            code.append(_plus_7);
            code.append("\treturn nil\n");
            code.append("}\n\n");
          }
          String _name_1 = contract.getName();
          String _plus_8 = ("func (sc *" + _name_1);
          String _plus_9 = (_plus_8 + ") Get");
          String _plus_10 = (_plus_9 + capitalizeAttributeName);
          String _plus_11 = (_plus_10 + "(ctx contractapi.TransactionContextInterface) (");
          String _plus_12 = (_plus_11 + attributeType);
          String _plus_13 = (_plus_12 + ", error) {\n");
          code.append(_plus_13);
          String _capitalizeFirstLetter_1 = this.capitalizeFirstLetter(attributeName);
          String _plus_14 = ("\treturn sc." + _capitalizeFirstLetter_1);
          String _plus_15 = (_plus_14 + ", nil\n");
          code.append(_plus_15);
          code.append("}\n\n");
        }
      }
      EList<Method> _methods = contract.getMethods();
      for (final Method method : _methods) {
        {
          String _name = contract.getName();
          String _plus = ("func (rc *" + _name);
          String _plus_1 = (_plus + ") ");
          String _capitalizeFirstLetter = this.capitalizeFirstLetter(method.getName());
          String _plus_2 = (_plus_1 + _capitalizeFirstLetter);
          String _plus_3 = (_plus_2 + "(ctx contractapi.TransactionContextInterface");
          String _appendParams = this.appendParams(method);
          String _plus_4 = (_plus_3 + _appendParams);
          String _plus_5 = (_plus_4 + ") error {\n");
          code.append(_plus_5);
          String _description = method.getDescription();
          boolean _tripleNotEquals = (_description != null);
          if (_tripleNotEquals) {
            String _description_1 = method.getDescription();
            String _plus_6 = ("\t// " + _description_1);
            String _plus_7 = (_plus_6 + "\n");
            code.append(_plus_7);
          }
          this.appendValidators(method, code);
          this.appendEvents(method, code);
          code.append("\treturn nil\n");
          code.append("}\n\n");
        }
      }
      StringBuilder _xifexpression = null;
      boolean _isHasReceive = contract.isHasReceive();
      if (_isHasReceive) {
        _xifexpression = this.appendReceiveMethod(contract, code);
      }
      _xblockexpression = _xifexpression;
    }
    return _xblockexpression;
  }
  
  public void appendValidators(final Method method, final StringBuilder code) {
    int _length = ((Object[])Conversions.unwrapArray(method.getValidators(), Object.class)).length;
    boolean _equals = (_length == 0);
    if (_equals) {
      return;
    }
    EList<Validator> _validators = method.getValidators();
    for (final Validator validator : _validators) {
      {
        String _checkCondition = this.checkCondition(validator.getValidation(), validator, method);
        String _plus = ("\tif " + _checkCondition);
        String _plus_1 = (_plus + " {\n");
        code.append(_plus_1);
        String _message = validator.getMessage();
        String _plus_2 = ("\t\treturn fmt.Errorf(\"" + _message);
        String _plus_3 = (_plus_2 + "\")\n");
        code.append(_plus_3);
        code.append("\t}\n\n");
      }
    }
  }
  
  public void appendEvents(final Method method, final StringBuilder code) {
    int _length = ((Object[])Conversions.unwrapArray(method.getEvents(), Object.class)).length;
    boolean _equals = (_length == 0);
    if (_equals) {
      return;
    }
    EList<Event> _events = method.getEvents();
    for (final Event event : _events) {
      {
        String _description = event.getDescription();
        boolean _tripleNotEquals = (_description != null);
        if (_tripleNotEquals) {
          String _description_1 = event.getDescription();
          String _plus = ("\t// " + _description_1);
          String _plus_1 = (_plus + "\n");
          code.append(_plus_1);
        }
        String _capitalizeFirstLetter = this.capitalizeFirstLetter(event.getName());
        String _plus_2 = ("\teventPayload := fmt.Sprintf(\"" + _capitalizeFirstLetter);
        String _checkEventParams = this.checkEventParams(event);
        String _plus_3 = (_plus_2 + _checkEventParams);
        code.append(_plus_3);
        String _capitalizeFirstLetter_1 = this.capitalizeFirstLetter(event.getName());
        String _plus_4 = ("\tctx.GetStub().SetEvent(\"" + _capitalizeFirstLetter_1);
        String _plus_5 = (_plus_4 + "\", []byte(eventPayload))\n\n");
        code.append(_plus_5);
      }
    }
  }
  
  public String appendParams(final Method method) {
    String result = "";
    EList<Param> _params = method.getParams();
    for (final Param param : _params) {
      {
        String _result = result;
        String _name = param.getName();
        String _plus = (" " + _name);
        String _plus_1 = (_plus + " ");
        String _correctType = this.getCorrectType(param.getType().toString());
        String _plus_2 = (_plus_1 + _correctType);
        result = (_result + _plus_2);
        Param _last = IterableExtensions.<Param>last(method.getParams());
        boolean _notEquals = (!Objects.equal(param, _last));
        if (_notEquals) {
          String _result_1 = result;
          result = (_result_1 + ",");
        }
      }
    }
    return result;
  }
  
  public String checkEventParams(final Event event) {
    String result = "";
    int _length = ((Object[])Conversions.unwrapArray(event.getParams(), Object.class)).length;
    boolean _greaterThan = (_length > 0);
    if (_greaterThan) {
      String _result = result;
      result = (_result + "-> ");
    } else {
      return "\")";
    }
    EList<Param> _params = event.getParams();
    for (final Param param : _params) {
      {
        String _result_1 = result;
        String _capitalizeFirstLetter = this.capitalizeFirstLetter(param.getName());
        String _plus = (_capitalizeFirstLetter + ": ");
        String _formatStringForType = this.getFormatStringForType(param.getType().toString());
        String _plus_1 = (_plus + _formatStringForType);
        result = (_result_1 + _plus_1);
        Param _last = IterableExtensions.<Param>last(event.getParams());
        boolean _notEquals = (!Objects.equal(param, _last));
        if (_notEquals) {
          String _result_2 = result;
          result = (_result_2 + ", ");
        } else {
          String _result_3 = result;
          result = (_result_3 + "\",");
        }
      }
    }
    EList<Param> _params_1 = event.getParams();
    for (final Param param_1 : _params_1) {
      {
        String name = param_1.getName();
        String _name = param_1.getName();
        boolean _equals = Objects.equal(_name, "from");
        if (_equals) {
          name = "ctx.GetClientIdentity().GetID()";
        }
        String _result_1 = result;
        result = (_result_1 + name);
        Param _last = IterableExtensions.<Param>last(event.getParams());
        boolean _notEquals = (!Objects.equal(param_1, _last));
        if (_notEquals) {
          String _result_2 = result;
          result = (_result_2 + ", ");
        }
      }
    }
    String _result_1 = result;
    result = (_result_1 + ")\n");
    return result;
  }
  
  public String checkCondition(final String condition, final Validator validator, final Method method) {
    final String regex = "([\\w.]+)\\s*([!=<>]+)\\s*([\\w.]+)";
    final Pattern pattern = Pattern.compile(regex);
    final Matcher matcher = pattern.matcher(condition);
    final HashMap<String, String> hashTable = new HashMap<String, String>();
    EList<Param> _params = validator.getParams();
    for (final Param param : _params) {
      hashTable.put(param.getName(), "validator");
    }
    EList<Param> _params_1 = method.getParams();
    for (final Param param_1 : _params_1) {
      hashTable.put(param_1.getName(), "param");
    }
    boolean _matches = matcher.matches();
    if (_matches) {
      String leftSide = matcher.group(1).replaceAll("\\s", "");
      String operator = matcher.group(2);
      String rightSide = matcher.group(3).replaceAll("\\s", "");
      if ((Objects.equal(leftSide, "msg.sender") || Objects.equal(leftSide, "from"))) {
        leftSide = "ctx.GetClientIdentity().GetID()";
      } else {
        final boolean isLeftSideNumber = leftSide.matches("\\d+");
        if (((isLeftSideNumber == false) && (!hashTable.containsKey(leftSide)))) {
          String _capitalizeFirstLetter = this.capitalizeFirstLetter(leftSide);
          String _plus = ("sc." + _capitalizeFirstLetter);
          leftSide = _plus;
        }
      }
      if ((Objects.equal(rightSide, "msg.sender") || Objects.equal(rightSide, "from"))) {
        rightSide = "ctx.GetClientIdentity().GetID()";
      } else {
        final boolean isRightSideNumber = rightSide.matches("\\d+");
        if (((isRightSideNumber == false) && (!hashTable.containsKey(rightSide)))) {
          String _capitalizeFirstLetter_1 = this.capitalizeFirstLetter(rightSide);
          String _plus_1 = ("sc." + _capitalizeFirstLetter_1);
          rightSide = _plus_1;
        }
      }
      return ((leftSide + operator) + rightSide);
    } else {
      return condition;
    }
  }
  
  public StringBuilder appendReceiveMethod(final Contract contract, final StringBuilder code) {
    StringBuilder _xblockexpression = null;
    {
      code.append("func (rc *ReceiveContract) Receive(ctx contractapi.TransactionContextInterface) error {\n");
      code.append("\targs := ctx.GetStub().GetArgs()\n");
      code.append("\tif len(args) > 0 {\n");
      code.append("\t\treturn fmt.Errorf(\"Receive function does not accept arguments\")\n");
      code.append("\t}\n");
      code.append("\teventPayload := fmt.Sprintf(\"PaymentReceived: %s, Amount: %d\", ctx.GetClientIdentity().GetID(), ctx.GetStub().GetTxID())\n");
      code.append("\tctx.GetStub().SetEvent(\"PaymentReceived\", []byte(eventPayload))\n");
      code.append("\treturn nil\n");
      _xblockexpression = code.append("}\n\n");
    }
    return _xblockexpression;
  }
  
  public StringBuilder appendMain(final Contract contract, final StringBuilder code) {
    StringBuilder _xblockexpression = null;
    {
      code.append("func main() {\n");
      String _name = contract.getName();
      String _plus = ("\tchaincode, err := contractapi.NewChaincode(&" + _name);
      String _plus_1 = (_plus + "{})\n");
      code.append(_plus_1);
      code.append("\tif err != nil {\n");
      String _name_1 = contract.getName();
      String _plus_2 = ("\t\tfmt.Printf(\"Error creating " + _name_1);
      String _plus_3 = (_plus_2 + " chaincode: %s\", err.Error())\n");
      code.append(_plus_3);
      code.append("\t\treturn\n");
      code.append("\t}\n\n");
      code.append("\tif err := chaincode.Start(); err != nil {\n");
      String _name_2 = contract.getName();
      String _plus_4 = ("\t\tfmt.Printf(\"Error starting " + _name_2);
      String _plus_5 = (_plus_4 + " chaincode: %s\", err.Error())\n");
      code.append(_plus_5);
      code.append("\t}\n");
      _xblockexpression = code.append("}\n");
    }
    return _xblockexpression;
  }
  
  public String getDefaultInitialValue(final String dataType) {
    if (dataType != null) {
      switch (dataType) {
        case "integer":
          return "0";
        case "string":
          return "\"\"";
        case "boolean":
          return "false";
        case "address":
          return "\"\"";
        case "array":
          return "[]uint64{}";
        default:
          return "uint64";
      }
    } else {
      return "uint64";
    }
  }
  
  public String getCorrectType(final String dataType) {
    if (dataType != null) {
      switch (dataType) {
        case "integer":
          return "uint64";
        case "string":
          return "string";
        case "boolean":
          return "bool";
        case "address":
          return "string";
        case "array":
          return "uint64[]";
        default:
          return "uint64";
      }
    } else {
      return "uint64";
    }
  }
  
  public String getFormatStringForType(final String dataType) {
    if (dataType != null) {
      switch (dataType) {
        case "integer":
          return "%d";
        case "string":
          return "%s";
        case "boolean":
          return "%t";
        case "address":
          return "%s";
        case "array":
          return "%s";
        default:
          return "%d";
      }
    } else {
      return "%d";
    }
  }
  
  public String capitalizeFirstLetter(final String str) {
    String _upperCase = str.substring(0, 1).toUpperCase();
    String _substring = str.substring(1);
    return (_upperCase + _substring);
  }
}
