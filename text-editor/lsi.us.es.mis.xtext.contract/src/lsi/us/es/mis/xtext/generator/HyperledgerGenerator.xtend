/*
 * generated by Xtext 2.25.0
 */
package lsi.us.es.mis.xtext.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import lsi.us.es.mis.xtext.contract.Contract
import lsi.us.es.mis.xtext.contract.Method
import java.util.regex.Pattern
import lsi.us.es.mis.xtext.contract.Validator
import lsi.us.es.mis.xtext.contract.Event
import java.util.HashMap


/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class HyperledgerGenerator extends AbstractGenerator {

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		var contract = resource.contents.head as Contract
		
		fsa.generateFile(contract.name + ".go", toHyperledger(contract))
	}
	
	def toHyperledger(Contract contract) {
	    val code = new StringBuilder
	   
	    appendHeader(contract, code)

	    appendAttributes(contract, code)

	    appendMethods(contract, code)
	    
	    appendConstructor(contract, code)
	    
	    appendMain(contract, code)
	    
	    return code.toString
	}
	
	def appendHeader(Contract contract, StringBuilder code) {
		code.append("package main\n\n")
	    code.append("import (\n")
	    code.append("\t\"fmt\"\n")
	    code.append("\n")
	    code.append("\t\"github.com/hyperledger/fabric-contract-api-go/contractapi\"\n")
	    code.append(")\n\n")
	}
		
	def appendConstructor(Contract contract, StringBuilder code) {
		code.append("func (sc *" + contract.name + ") InitLedger(ctx contractapi.TransactionContextInterface) error {\n")
	    
	    for (attribute : contract.attributes) {
	        val defaultValue = getDefaultInitialValue(attribute.type.toString)
	        code.append("\tsc." + attribute.name + " = " + defaultValue + "\n")
	    }
	    
	    if (contract.ownership){
	    	code.append("\tsc.owner = ctx.GetClientIdentity().GetID()\n")
	    }
	    
	    code.append("\treturn nil\n")
	    code.append("}\n\n")
	}
	
	def appendAttributes(Contract contract, StringBuilder code) {
		code.append("type " + contract.name + " struct {\n")
	    code.append("\tcontractapi.Contract\n")
	    
	    if (contract.ownership) {
	    	code.append("\towner string\n")
	    }
	     
	    for (map: contract.dataStores) {
	    	code.append("\t" + map.name + " map["+getCorrectType(map.fromType.toString)+"]" + getCorrectType(map.toType.toString) + "\n")
	    }
	    
	    
	    for (attribute : contract.attributes) {
	        val attributeType = getCorrectType(attribute.type.toString)
	        code.append("\t" + attribute.name + " " + attributeType + "\n")
	    }
	    
	    code.append("}\n\n")
	}
	
	def appendMethods(Contract contract, StringBuilder code) {
		for (attribute : contract.attributes) {
	        val attributeName = attribute.name
	        val capitalizeAttributeName = capitalizeFirstLetter(attributeName)
	        val attributeType = getCorrectType(attribute.type.toString)
	        
	        if (attribute.modifiable) {
		        code.append("func (sc *" + contract.name + ") Set" + capitalizeAttributeName + "(ctx contractapi.TransactionContextInterface, value " + attributeType + ") error {\n")
		        code.append("\tsc." + attributeName + " = value\n")
		        code.append("\treturn nil\n")
		        code.append("}\n\n")
	        }
	        
	        code.append("func (sc *" + contract.name + ") Get" + capitalizeAttributeName + "(ctx contractapi.TransactionContextInterface) (" + attributeType + ", error) {\n")
	        code.append("\treturn sc." + attributeName + ", nil\n")
	        code.append("}\n\n")
	    }
	    
	    for (method : contract.methods){
	    	code.append("func (sc *"+contract.name +") "+ capitalizeFirstLetter(method.name) +"(ctx contractapi.TransactionContextInterface"+appendParams(method)+") error {\n")
	    	
			if (method.description !== null){
	        	code.append("\t// " + method.description + "\n")
	        }
	        
	       	appendValidators(method, code)
	    
	    	appendEvents(method, code)
	     
	    	code.append("\treturn nil\n")
	    	code.append("}\n\n")
	    }
	    
	    if (contract.hasReceive){
	    	appendReceiveMethod(contract, code)
	    }
	}
	
	def appendValidators(Method method, StringBuilder code){
		if (method.validators.length == 0){
			return
		}
		
		for (validator: method.validators){
			code.append("\tif " + checkCondition(validator.validation, validator, method) + " {\n")
			code.append("\t\treturn fmt.Errorf(\""+ validator.message +"\")\n")
			code.append("\t}\n\n")
		}
	}
	
	def appendEvents(Method method, StringBuilder code){
		
		var alreadyDeclareEventPayload = false
		
		if (method.events.length == 0){
			return
		}
		
		for (event: method.events){
			if (event.description !== null){
	        	code.append("\t// " + event.description + "\n")
	        	
	        }
	        
	        if (alreadyDeclareEventPayload){
	        	code.append("\teventPayload = fmt.Sprintf(\""+ capitalizeFirstLetter(event.name) + checkEventParams(event))
	        }else  {
	        	code.append("\teventPayload := fmt.Sprintf(\""+ capitalizeFirstLetter(event.name) + checkEventParams(event))
	        }
	        code.append("\tctx.GetStub().SetEvent(\""+ capitalizeFirstLetter(event.name)+"\", []byte(eventPayload))\n\n")
	        alreadyDeclareEventPayload = true
		}
	}
	
	def String appendParams(Method method){
		var result = ""
		for (param: method.params){
			result += ", " + param.name + " " + getCorrectType(param.type.toString)
		}
		return result
	}
	
	def String checkEventParams(Event event){
		var result = ""
		if (event.params.length > 0) {
			result += "-> "
		} else {
			return "\")"
		}
		
		for (param: event.params){
			result += capitalizeFirstLetter(param.name)+": " + getFormatStringForType(param.type.toString)
			if (param != event.params.last) {
				result += ", "
			} else {
				result += "\","
			}
		}
		
		for (param: event.params){
			var name = param.name
			if (param.name == "from") {
				name = "ctx.GetClientIdentity().GetID()"
			}
			result += name
			if (param != event.params.last) {
				result += ", "
			}
		}
		result +=")\n"
		return result
	}
	
	def String checkCondition(String condition, Validator validator, Method method){
		val regex = "([\\w.\\[\\]]+)\\s*([!=<>]+)\\s*([\\w.]+)";
		val pattern = Pattern.compile(regex)
		val matcher = pattern.matcher(condition)
		
		val regex2 = "\\s*(\\w+)\\s*==\\s*'([^']+)'"
		val pattern2 = Pattern.compile(regex2)
		val matcher2 = pattern2.matcher(condition)
		
		val hashTable = new HashMap<String, String>()
		
		for (param: validator.params) {
			hashTable.put(param.name, "validator")
		}
		
		for (param: method.params) {
			hashTable.put(param.name, "param")
		}
		
		hashTable.put("ctx.GetClientIdentity().GetID()", "id")
		
		if (matcher.matches) {
            var leftSide = matcher.group(1).replaceAll("\\s", "")
            var operator = matcher.group(2)
            var rightSide = matcher.group(3).replaceAll("\\s", "")
            
            leftSide = leftSide.replace("from", "ctx.GetClientIdentity().GetID()")
            leftSide = leftSide.replace("msg.sender", "ctx.GetClientIdentity().GetID()")
        	val isLeftSideNumber = leftSide.matches("\\d+")
        	if (isLeftSideNumber == false && !hashTable.containsKey(leftSide)){
        		leftSide = "sc."+leftSide
        	}
			rightSide = rightSide.replace("from", "ctx.GetClientIdentity().GetID()")
        	rightSide = rightSide.replace("msg.sender", "ctx.GetClientIdentity().GetID()")
        	val isRightSideNumber = rightSide.matches("\\d+")
        	if (isRightSideNumber == false && !hashTable.containsKey(rightSide)){
        		rightSide = "sc."+rightSide
        	}
            return leftSide+operator+rightSide
        } else if(matcher2.matches) {
        	 val variable = matcher2.group(1)
    	     if(!variable.matches("\\d+") && !hashTable.containsKey(variable)){
    	     	return condition.replace(variable, "sc."+variable).replace("'","\"")
    	     }
        }
        else {
            return condition
        }
	}
	
	def appendReceiveMethod(Contract contract, StringBuilder code){
    	code.append("func (sc *"+contract.name+") Receive(ctx contractapi.TransactionContextInterface) error {\n")
    	code.append("\targs := ctx.GetStub().GetArgs()\n")
    	code.append("\tif len(args) > 0 {\n")
    	code.append("\t\treturn fmt.Errorf(\"Receive function does not accept arguments\")\n")
    	code.append("\t}\n")
    	code.append("\teventPayload := fmt.Sprintf(\"PaymentReceived: %s, Amount: %d\", ctx.GetClientIdentity().GetID(), ctx.GetStub().GetTxID())\n")
    	code.append("\tctx.GetStub().SetEvent(\"PaymentReceived\", []byte(eventPayload))\n")
    	code.append("\treturn nil\n")
    	code.append("}\n\n")
	}
	
	def appendMain(Contract contract, StringBuilder code){
		code.append("func main() {\n")
	    code.append("\tchaincode, err := contractapi.NewChaincode(&" + contract.name + "{})\n")
	    code.append("\tif err != nil {\n")
	    code.append("\t\tfmt.Printf(\"Error creating " + contract.name + " chaincode: %s\", err.Error())\n")
	    code.append("\t\treturn\n")
	    code.append("\t}\n\n")
	    code.append("\tif err := chaincode.Start(); err != nil {\n")
	    code.append("\t\tfmt.Printf(\"Error starting " + contract.name + " chaincode: %s\", err.Error())\n")
	    code.append("\t}\n")
	    code.append("}\n")
	} 
	
	def String getDefaultInitialValue(String dataType) {
	    switch (dataType) {
	        case "integer":
	            return "0"
	        case "string":
	            return "\"\""
	        case "boolean":
	            return "false"
	        case "address":
	            return "\"\""
	        case "array":
	            return "[]uint64{}"
	        default:
	            return "uint64"
	    }
	}
	
	def String getCorrectType(String dataType) {
	    switch (dataType) {
	        case "integer":
	            return "uint64"
	        case "string":
	            return "string"
	        case "boolean":
	            return "bool"
	        case "address":
	            return "string"
	        case "array":
	            return "uint64[]"
	        default:
	            return "uint64"
	    }
	}
	
	def String getFormatStringForType(String dataType) {
	    switch (dataType) {
	        case "integer":
	            return "%d"
	        case "string":
	            return "%s"
	        case "boolean":
	            return "%t"
	        case "address":
	            return "%s"
	        case "array":
	            return "%s"
	        default:
	            return "%d"
	    }
	}
	
	def String capitalizeFirstLetter(String str) {
	    return str.substring(0, 1).toUpperCase() + str.substring(1)
	}
}
