/*
 * generated by Xtext 2.25.0
 */
package lsi.us.es.mis.xtext.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import lsi.us.es.mis.xtext.contract.Contract

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class FireflyInterfaceGenerator extends AbstractGenerator {

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		var contract = resource.contents.head as Contract
		
		fsa.generateFile(contract.name + ".sol", toSolidity(contract))
	}
	
	def String toFireflyInterface(Contract contract) {
	    val namespace = "default"
	    val name = contract.name
	    val description = "Description of the smart contract"
	    val version = contract.version
	    
	    var methods = ""
	    for (method : contract.methods) {
	        val methodName = method.name
	        val methodDescription = method.description ?: ""
	        
	        val params = method.params.map[p |
	            val paramName = p.name
	            val paramType = p.type
	            val paramSchemaType = p.schema.type
	            val paramSchemaDetailsType = p.schema.details.type ?: ""
	            val paramSchemaDetailsInternalType = p.schema.details.internalType ?: ""
	            val paramSchemaDetailsIndexed = p.schema.details.indexed ?: "false"
	            
	            '''
	            {
	                "name": "$paramName",
	                "type": "$paramType",
	                "schema": {
	                    "type": "$paramSchemaType",
	                    "details": {
	                        "type": "$paramSchemaDetailsType",
	                        "internalType": "$paramSchemaDetailsInternalType",
	                        "indexed": $paramSchemaDetailsIndexed
	                    }
	                }
	            }
	            '''
	        ].join(",\n")
	        
	        val returnsType = method.returns.type
	        val returnsSchemaType = method.returns.schema.type
	        val returnsSchemaDetailsType = method.returns.schema.details.type ?: ""
	        val returnsSchemaDetailsInternalType = method.returns.schema.details.internalType ?: ""
	        val returnsSchemaDetailsIndexed = method.returns.schema.details.indexed ?: "false"
	        
	        val methodCode = '''
	        {
	            "name": "$methodName",
	            "description": "$methodDescription",
	            "params": [
	                $params
	            ],
	            "returns": {
	                "type": "$returnsType",
	                "schema": {
	                    "type": "$returnsSchemaType",
	                    "details": {
	                        "type": "$returnsSchemaDetailsType",
	                        "internalType": "$returnsSchemaDetailsInternalType",
	                        "indexed": $returnsSchemaDetailsIndexed
	                    }
	                }
	            }
	        }
	        '''
	        
	        methods += methodCode + ",\n"
	    }
	    
	    val interfaceCode = '''
	    {
	        "namespace": "$namespace",
	        "name": "$name",
	        "description": "$description",
	        "version": "$version",
	        "methods": [
	            $methods
	        ],
	        "events": []
	    }
	    '''
	    
	    return interfaceCode
	}

	def String getSolidityDataType(String dataType) {
	    switch (dataType) {
	        case "integer":
	            return "uint256"
	        case "string":
	            return "string"
	        case "boolean":
	            return "bool"
	        case "address":
	            return "address"
	        case "array":
	            return "uint256[]"
	        default:
	            return "uint256"
	    }
	}
	
	def String getSolidityDataTypeForFunction(String dataType) {
		switch (dataType) {
	        case "integer":
	            return "uint256"
	        case "string":
	            return "string memory"
	        case "boolean":
	            return "bool"
	        case "address":
	            return "address"
	        case "array":
	            return "uint256[]"
	        default:
	            return "uint256"
	    }
	}

	def String capitalizeFirstLetter(String str) {
	    return str.substring(0, 1).toUpperCase() + str.substring(1)
	}
	
	
}
